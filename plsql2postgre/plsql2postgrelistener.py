"""Traverse the AST generated by parser and adapt script to suit postgreSQL's grammar.

    [class]PlSql2PostgreListener - Traverse the AST generated by parser
                                   and adapt script to suit postgreSQL's grammar.
                                   *Based on class "PlSqlParserListener" generated by ANTLR4.
"""
import re

from antlr4                     import TokenStream, TerminalNode
from antlr4.TokenStreamRewriter import TokenStreamRewriter

if __name__ is not None and "." in __name__:
    from .PlSqlParserListener   import PlSqlParserListener
    from .PlSqlParser           import PlSqlParser
    from .PlSqlLexer            import PlSqlLexer
else:
    from PlSqlParserListener    import PlSqlParserListener
    from PlSqlParser            import PlSqlParser
    from PlSqlLexer             import PlSqlLexer

class PlSql2PostgreListener(PlSqlParserListener):
    """Traverse the AST generated by parser and adapt script to suit postgreSQL's grammar.

        [property]tokens   - Get the original token stream.
        [property]rewriter - Get the object to change the original token stream.

        [method]... - Replace the necessary methods of base class and do not provide new method.
    """
    __DATA_TYPE = {
                'BFILE'         :'BYTEA',
                'BINARY_DOUBLE' :'DOUBLE PRECISION',
                'BINARY_FLOAT'  :'DOUBLE PRECISION',
                'BINARY_INTEGER':'INTEGER',
                'BLOB'          :'BYTEA',
                'CLOB'          :'TEXT',
                'DATE'          :'TIMESTAMP',
                'DEC'           :'DECIMAL',
                'FLOAT'         :'DOUBLE PRECISION',
                'INT'           :'INTEGER',
                'LONG'          :'TEXT',
                'NCHAR'         :'CHAR',
                'NCLOB'         :'TEXT',
                'NVARCHAR2'     :'VARCHAR',
                'NUMBER'        :'NUMERIC',
                'PLS_INTEGER'   :'INTEGER',
                'RAW'           :'BYTEA',
                'ROWID'         :'OID',
                'VARCHAR2'      :'VARCHAR'
                }
    __EXT_FSERVER_NAME = 'PG_FILE_SERVER'
    __NEW_LINE = '\n'

    def __init__(self, tokens: TokenStream):
        """Init the properties of class.

            [argument]tokens - Set the original token stream.
        """
        self.tokens = tokens
        self.rewriter = TokenStreamRewriter(tokens)
        self.__query_elements = []
        self.__crtl_elements = []

    def __replace_remark(self):
        """Convert all remark comments to -- comments."""
        for token in self.tokens.tokens:
            if token.channel == PlSqlLexer.REMCOMMENTS:
                txt = token.text
                if txt[:6].upper() == 'REMARK':
                    new_txt = '--' + txt[6:]
                else:
                    new_txt = '--' + txt[3:]
                self.rewriter.replaceSingleToken(token, new_txt)

    @staticmethod
    def __replace_quote_bindvar(str_origin):
        """Replace bind variant in string constant."""
        if str_origin[-1] != "'":
            return str_origin

        pattern = re.compile(r'([^&]*)(&[0-9]+|&[a-zA-Z][a-zA-Z0-9_]*)(.*)')
        str_proc = str_origin
        str_ret = ""
        result = pattern.match(str_proc)
        if not result:
            return str_origin
        while result:
            str_ret = str_ret + "' || " if str_ret else str_ret
            if result.group(1) == "'":
                str_ret = str_ret + ":'" + result.group(2)[1:]
            else:
                str_ret = str_ret + result.group(1) + "' || :'" + result.group(2)[1:]
            if result.group(3) != "'":
                str_proc = "'" + result.group(3)
            else:
                str_proc = result.group(3)
            result = pattern.match(str_proc)
        if str_proc == "'":
            str_ret = str_ret + str_proc
        else:
            str_ret = str_ret + "' || " + str_proc
        return str_ret

    def __comment_context(self, ctx):
        """Comment the whole content."""
        self.rewriter.replaceSingleToken(ctx.start, '/* '+ctx.start.text)
        self.rewriter.replaceSingleToken(ctx.stop, ctx.stop.text+' */')

    def exitSql_script(self, ctx: PlSqlParser.Sql_scriptContext):
        """Exit a parse tree produced by PlSqlParser#sql_script."""
        self.__replace_remark()

    def exitSql_plus_command(self, ctx: PlSqlParser.Sql_plus_commandContext):
        """Exit a parse tree produced by PlSqlParser#sql_plus_command."""
        token = ctx.start
        txt = token.text
        #Convert / command to nothing
        if txt == '/':
            self.rewriter.replaceSingleToken(token, '')
        #Convert exit command to \q
        elif txt.upper() == 'EXIT':
            self.rewriter.replaceSingleToken(token, r'\q')
        #Convert prompt command to \echo
        elif txt[:6].upper() == 'PROMPT':
            self.rewriter.replaceSingleToken(token, r'\echo' + txt[6:])
        elif txt[:3].upper() == 'PRO':
            self.rewriter.replaceSingleToken(token, r'\echo' + txt[3:])
        #Convert 'show errors' command to \errverbose
        elif txt.upper() == 'SHOW':
            self.rewriter.replaceSingleToken(token, r'\errverbose')
            self.rewriter.replaceSingleToken(ctx.stop, '')

    def exitWhenever_command(self, ctx: PlSqlParser.Whenever_commandContext):
        """Exit a parse tree produced by PlSqlParser#whenever_command."""
        self.__comment_context(ctx)

    def exitSet_command(self, ctx: PlSqlParser.Set_commandContext):
        """Exit a parse tree produced by PlSqlParser#set_command."""
        #Comment whole command at first
        self.__comment_context(ctx)
        #Change some system variable by postgre's manner
        child_num = len(ctx.children)
        var_name = ''
        var_value = ''
        if child_num >= 2:
            var_name = ctx.children[1].getText()
        if child_num >= 3:
            var_value = ctx.children[2].getText()
        #Autocommit config
        if var_name.upper() in ('AUTO', 'AUTOCOMMIT'):
            if var_value.upper() not in ('ON', 'OFF'):
                var_value = 'on'
            new_txt = self.__NEW_LINE + r'\set AUTOCOMMIT ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Colsep config
        elif var_name.upper() == 'COLSEP':
            new_txt = self.__NEW_LINE + r'\pset fieldsep ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Echo config
        elif var_name.upper() == 'ECHO':
            new_txt = self.__NEW_LINE + r'\set ECHO_HIDDEN ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Linesize config
        elif var_name.upper() in ('LIN', 'LINESIZE'):
            new_txt = self.__NEW_LINE + r'\pset columns ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Null text config
        elif var_name.upper() == 'NULL':
            new_txt = self.__NEW_LINE + r'\pset null ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Pagesize config
        elif var_name.upper() in ('PAGES', 'PAGESIZE'):
            new_txt = self.__NEW_LINE + r'\pset pager_min_lines ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Recsepchar config
        elif var_name.upper() == 'RECSEPCHAR':
            new_txt = self.__NEW_LINE + r'\pset recordsep ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)
        #Timing config
        elif var_name.upper() in ('TIMI', 'TIMING'):
            new_txt = self.__NEW_LINE + r'\timing ' + var_value
            self.rewriter.insertAfterToken(ctx.stop, new_txt)

    def exitDefine_command(self, ctx: PlSqlParser.Define_commandContext):
        """Exit a parse tree produced by PlSqlParser#define_command."""
        #Convert define command to \set and erase '=' sign
        self.rewriter.replaceSingleToken(ctx.start, r'\set')
        if ctx.EQUALS_OP():
            self.rewriter.replaceSingleToken(ctx.EQUALS_OP().symbol, '')

    def exitString_function(self, ctx: PlSqlParser.String_functionContext):
        """Exit a parse tree produced by PlSqlParser#string_function."""
        fname_token = ctx.start
        #Change NVL function to COALESCE
        if fname_token.text.upper() == 'NVL':
            self.rewriter.replaceSingleToken(fname_token, 'COALESCE')

    def exitRegular_id(self, ctx: PlSqlParser.Regular_idContext):
        """Exit a parse tree produced by PlSqlParser#regular_id."""
        #Convert variable's sign from '&' to ':'
        if ctx.start.text == '&':
            self.rewriter.replaceSingleToken(ctx.start, ':')
        #Convert sysdate to current_timestamp
        elif ctx.start.text.upper() == 'SYSDATE':
            self.rewriter.replaceSingleToken(ctx.start, 'CURRENT_TIMESTAMP')

    def exitPhysical_attributes_clause(self, ctx: PlSqlParser.Physical_attributes_clauseContext):
        """Exit a parse tree produced by PlSqlParser#physical_attributes_clause."""
        #Convert variable's sign from '&' to ':'
        if ctx.AMPERSAND():
            for child in ctx.AMPERSAND():
                self.rewriter.replaceSingleToken(child.symbol, ':')

    def exitLiteral(self, ctx: PlSqlParser.LiteralContext):
        """Exit a parse tree produced by PlSqlParser#literal."""
        #Convert variable's sign from '&' to ':'
        if ctx.AMPERSAND():
            for child in ctx.AMPERSAND():
                self.rewriter.replaceSingleToken(child.symbol, ':')

    def exitNative_datatype_element(self, ctx: PlSqlParser.Native_datatype_elementContext):
        """Exit a parse tree produced by PlSqlParser#native_datatype_element."""
        #Convert datatype
        if len(ctx.children) == 1:
            if ctx.start.text.upper() in self.__DATA_TYPE.keys():
                new_txt = self.__DATA_TYPE[ctx.start.text.upper()]
                self.rewriter.replaceSingleToken(ctx.start, new_txt)
        else:
            #Convert LONG ROW type
            if ctx.start.text.upper() == 'LONG':
                self.rewriter.replaceSingleToken(ctx.start, 'BYTEA')
                self.rewriter.replaceSingleToken(ctx.stop, '')

    def exitQuoted_string(self, ctx: PlSqlParser.Quoted_stringContext):
        """Exit a parse tree produced by PlSqlParser#quoted_string."""
        #Convert variable's sign from '&' to ':' in string
        self.rewriter.replaceSingleToken(ctx.start, self.__replace_quote_bindvar(ctx.start.text))

    def exitLogging_clause(self, ctx: PlSqlParser.Logging_clauseContext):
        """Exit a parse tree produced by PlSqlParser#logging_clause."""
        #Comment logging clause
        self.rewriter.replaceSingleToken(ctx.start, r'/* ' + ctx.start.text + r' */')

    def exitAnonymous_block(self, ctx: PlSqlParser.Anonymous_blockContext):
        """Exit a parse tree produced by PlSqlParser#anonymous_block."""
        #Insert DO statement
        self.rewriter.replaceSingleToken(ctx.start, 'DO $$' + self.__NEW_LINE + ctx.start.text)
        self.rewriter.replaceSingleToken(ctx.stop, '$$' + ctx.stop.text)

    def exitExecute_immediate(self, ctx: PlSqlParser.Execute_immediateContext):
        """Exit a parse tree produced by PlSqlParser#execute_immediate."""
        #Delete keyword immediate
        self.rewriter.replaceSingleToken(ctx.IMMEDIATE().symbol, '')

    def exitCreate_synonym(self, ctx: PlSqlParser.Create_synonymContext):
        """Exit a parse tree produced by PlSqlParser#create_synonym."""
        #Delete public keyword
        if ctx.PUBLIC():
            self.rewriter.replaceSingleToken(ctx.PUBLIC().symbol, '')
        #Change synonym to view
        self.rewriter.replaceSingleToken(ctx.SYNONYM().symbol, 'VIEW')
        #Change for keyword to "as select * from"
        self.rewriter.replaceSingleToken(ctx.FOR().symbol, 'AS SELECT * FROM')

    def exitDrop_synonym(self, ctx: PlSqlParser.Drop_synonymContext):
        """Exit a parse tree produced by PlSqlParser#drop_synonym."""
        #Delete public keyword
        if ctx.PUBLIC():
            self.rewriter.replaceSingleToken(ctx.PUBLIC().symbol, '')
        #Change synonym to view
        self.rewriter.replaceSingleToken(ctx.SYNONYM().symbol, 'VIEW')
        #Change force to cascade
        if ctx.FORCE():
            self.rewriter.replaceSingleToken(ctx.FORCE().symbol, 'CASCADE')

    def exitDrop_view(self, ctx: PlSqlParser.Drop_viewContext):
        """Exit a parse tree produced by PlSqlParser#drop_view."""
        #Force to cascade and delete constraints
        if ctx.CASCADE():
            self.rewriter.replaceSingleToken(ctx.CONSTRAINTS().symbol, '')
        else:
            self.rewriter.replaceSingleToken(ctx.SEMICOLON().symbol, ' CASCADE;')

    def exitDrop_function(self, ctx: PlSqlParser.Drop_functionContext):
        """Exit a parse tree produced by PlSqlParser#drop_function."""
        #Force to cascade and add parameters list
        self.rewriter.replaceSingleToken(ctx.stop, '() CASCADE;')

    def exitAlter_function(self, ctx: PlSqlParser.Alter_functionContext):
        """Exit a parse tree produced by PlSqlParser#alter_function."""
        self.__comment_context(ctx)

    def enterQuery_block(self, ctx: PlSqlParser.Query_blockContext):
        """Enter a parse tree produced by PlSqlParser#query_block."""
        #Allocate select statement's infomation area
        self.__query_elements.append({'select_list':[],
                                      'from_list':[],
                                      'where_list':[]})

    def enterSelected_list(self, ctx: PlSqlParser.Selected_listContext):
        """Enter a parse tree produced by PlSqlParser#selected_list."""
        if self.__query_elements:
            query_element = self.__query_elements[-1]
            select_list = []
            for child in ctx.children:
                if isinstance(child, TerminalNode):
                    if child.symbol.text == '*':
                        select_list.append(child.symbol.text)
                else:
                    select_list.append(child.getText())
            query_element['select_list'] = select_list

    def enterTable_ref_list(self, ctx: PlSqlParser.Table_ref_listContext):
        """Enter a parse tree produced by PlSqlParser#table_ref_list."""
        if self.__query_elements:
            query_element = self.__query_elements[-1]
            from_list = []
            for child in ctx.children:
                if not isinstance(child, TerminalNode):
                    from_list.append(child.getText())
            query_element['from_list'] = from_list

    def enterWhere_clause(self, ctx: PlSqlParser.Where_clauseContext):
        """Enter a parse tree produced by PlSqlParser#where_clause."""
        if self.__query_elements:
            query_element = self.__query_elements[-1]
            where_list = ''
            for child in ctx.children:
                if child.getText() != 'WHERE':
                    where_list = where_list + child.getText()
            query_element['where_list'] = where_list

    def exitQuery_block(self, ctx: PlSqlParser.Query_blockContext):
        """Exit a parse tree produced by PlSqlParser#query_block."""
        query_element = self.__query_elements.pop()
        #If from dual then comment from clause
        if query_element['from_list'][0].upper() == 'DUAL':
            from_ctx = ctx.from_clause()
            self.rewriter.replaceSingleToken(from_ctx.start, '/* '+ from_ctx.start.text)
            self.rewriter.replaceSingleToken(from_ctx.stop, from_ctx.stop.text+' */')

    def enterCreate_table(self, ctx: PlSqlParser.Create_tableContext):
        """Enter a parse tree produced by PlSqlParser#create_table."""
        #Allocate create table statement's infomation area
        self.__crtl_elements.append({'foreign_table':False,
                                     'file_location':''})

    def enterExternal_table_clause(self, ctx: PlSqlParser.External_table_clauseContext):
        """Enter a parse tree produced by PlSqlParser#external_table_clause."""
        if self.__crtl_elements:
            crtl_element = self.__crtl_elements[-1]
            crtl_element['foreign_table'] = True

    def enterExternal_data_properties(self, ctx: PlSqlParser.External_data_propertiesContext):
        """Enter a parse tree produced by PlSqlParser#external_data_properties."""
        if self.__crtl_elements:
            crtl_element = self.__crtl_elements[-1]
            crtl_element['file_location'] = \
                           self.__replace_quote_bindvar(ctx.quoted_string()[0].getText())

    def exitPhysical_properties(self, ctx: PlSqlParser.Physical_propertiesContext):
        """Exit a parse tree produced by PlSqlParser#physical_properties."""
        if self.__crtl_elements:
            crtl_element = self.__crtl_elements[-1]
            if crtl_element['foreign_table']:
                token = ctx.ORGANIZATION().symbol
                self.rewriter.replaceSingleToken(token, '/* ' + token.text)
                token = ctx.external_table_clause().stop
                self.rewriter.replaceSingleToken(token, token.text + ' */')
                new_txt = self.__NEW_LINE + 'SERVER ' + self.__EXT_FSERVER_NAME
                new_txt = new_txt + self.__NEW_LINE + 'OPTIONS ('
                new_txt = new_txt + self.__NEW_LINE + "    FILENAME "
                new_txt = new_txt + crtl_element['file_location']
                new_txt = new_txt + self.__NEW_LINE + ')'
                self.rewriter.insertAfterToken(token, new_txt)

    def exitCreate_table(self, ctx: PlSqlParser.Create_tableContext):
        """Exit a parse tree produced by PlSqlParser#create_table."""
        crtl_element = self.__crtl_elements.pop()
        if crtl_element['foreign_table']:
            token = ctx.TABLE().symbol
            self.rewriter.replaceSingleToken(token, 'FOREIGN ' + token.text)
